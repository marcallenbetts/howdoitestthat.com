{"data":{"site":{"siteMetadata":{"title":"How Do I Test That?","author":"Marc Betts","labels":[{"tag":"react","tech":"React","name":"DiReact","size":20,"color":"deepskyblue"},{"tag":"git","tech":"Git","name":"DiGitMerge","size":20,"color":"white"},{"tag":"javascript","tech":"JavaScript","name":"DiJsBadge","size":20,"color":"yellow"},{"tag":"css","tech":"CSS","name":"DiCss3Full","size":20,"color":"teal"},{"tag":"python","tech":"Python","name":"DiPython","size":20,"color":"deepskyblue"},{"tag":"nodejs","tech":"Node.js","name":"DiNodejsSmall","size":20,"color":"lightgreen"},{"tag":"ruby","tech":"Ruby","name":"DiRuby","size":20,"color":"crimson"},{"tag":"java","tech":"Java","name":"FaJava","size":20,"color":"wheat"},{"tag":"angular","tech":"Angular","name":"DiAngularSimple","size":20,"color":"red"},{"tag":"html","tech":"HTML","name":"FaHtml5","size":20,"color":"darkorange"},{"tag":"php","tech":"php","name":"DiPhp","size":20,"color":"violet"},{"tag":"mongodb","tech":"MongoDB","name":"DiMongodb","size":20,"color":"green"},{"tag":"mongoose","tech":"Mongoose","name":"DiMongodb","size":20,"color":"green"},{"tag":"vscode","tech":"VS Code","name":"DiVisualstudio","size":20,"color":"deepskyblue"},{"tag":"android","tech":"Android","name":"DiAndroid","size":20,"color":"green"},{"tag":"cli","tech":"cli","name":"DiTerminal","size":20,"color":"white"},{"tag":"curl","tech":"curl","name":"DiTerminal","size":20,"color":"white"},{"tag":"mobile","tech":"Mobile","name":"FaMobileAlt","size":20,"color":"white"},{"tag":"proxy","tech":"proxy","name":"FaServer","size":20,"color":"white"},{"tag":"charlesproxy","tech":"Charles Proxy","name":"FaTools","size":20,"color":"white"},{"tag":"mitmproxy","tech":"mitmproxy","name":"FaTools","size":20,"color":"white"},{"tag":"postman","tech":"Postman","name":"DiTerminal","size":20,"color":"white"},{"tag":"newman","tech":"Newman","name":"FaTools","size":20,"color":"white"},{"tag":"express","tech":"Express","name":"FaJsSquare","size":20,"color":"white"},{"tag":"webserver","tech":"webserver","name":"FaServer","size":20,"color":"white"},{"tag":"nginx","tech":"NGINX","name":"FaServer","size":20,"color":"white"},{"tag":"apitesting","tech":"API Testing","name":"FaServer","size":20,"color":"white"},{"tag":"serveo","tech":"Serveo","name":"FaTools","size":20,"color":"white"},{"tag":"ngrok","tech":"ngrok","name":"FaTools","size":20,"color":"white"},{"tag":"localtunnel","tech":"Localtunnel","name":"FaTools","size":20,"color":"white"},{"tag":"network","tech":"Network","name":"FaEthernet","size":20,"color":"white"},{"tag":"lodash","tech":"Lodash","name":"FaJsSquare","size":20,"color":"white"},{"tag":"moment","tech":"Moment","name":"FaJsSquare","size":20,"color":"white"}]}},"allMarkdownRemark":{"totalCount":11,"edges":[{"node":{"excerpt":"I've been using mitmproxy pretty much non-stop for the\npast several months. My current daily workflow consists of a proxy and two reverse \nproxies.From anywhere within mitmproxy, entering  will…","html":"<p>I've been using <a href=\"https://mitmproxy.org/\">mitmproxy</a> pretty much non-stop for the\npast several months. My current daily workflow consists of a proxy and two reverse\nproxies.</p>\n<p>From anywhere within mitmproxy, entering <code class=\"language-text\">?</code> will display context-sensitive help. For\nthe most part, the documentation is great. The one thing I was not able to find\nwas how to export a request as a curl request, which are useful when trying to share\nrequests with team mates.</p>\n<p>After Googling it for a bit, I finally came across how to do it:</p>\n<ul>\n<li>enter <code class=\"language-text\">w</code> to enter export mode</li>\n<li>enter <code class=\"language-text\">export.clip curl @focus</code> to copy curl request to clipboard</li>\n</ul>\n<p>It works, but I'm still going to reference my notes I need to remember the\nexact syntax. Luckily, mitmproxy has <a href=\"https://docs.mitmproxy.org/stable/tools-mitmproxy/\">key binding</a>\nsupport. So, by adding the following to <code class=\"language-text\">~/.mitmproxykeys.yaml</code>\nI now have a shortcut to copy a curl request from mitmproxy.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-\n  key: c\n  cmd: export.clip curl @focus</code></pre></div>","id":"d74fb15a-052a-5990-9a0e-313f2403d774","frontmatter":{"title":"export curl from mitmproxy","date":"July 20, 2019","tags":["mimiproxy","proxy","cli","curl"]},"fields":{"slug":"/export-curl-from-mitm-proxy/"}}},{"node":{"excerpt":"I use Charles Proxy pretty much nonstop when \ntesting. As a backup I use mitmproxy. It lacks a bit\nof the polished UI that Charles provides, but it is free and open source. And it\ngets cool points for…","html":"<p>I use <a href=\"https://www.charlesproxy.com/\">Charles Proxy</a> pretty much nonstop when\ntesting. As a backup I use <a href=\"https://mitmproxy.org/\">mitmproxy</a>. It lacks a bit\nof the polished UI that Charles provides, but it is free and open source. And it\ngets cool points for being a command line tool.</p>\n<p>These notes cover only a fraction of what mitmproxy can do, but is pretty much\neverything I need most days.</p>\n<h3>Install</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">brew install mitmproxy</code></pre></div>\n<h3>Help</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mitmproxy --help</code></pre></div>\n<h3>Start proxy on port 8989</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mitmproxy --listen-port 8989 --ssl-insecure \n--set console_mouse=false</code></pre></div>\n<p>The <code class=\"language-text\">ssl-insecure</code> flag ignores insecure SSL sites, which is common in\na lot of the test environments I use. The <code class=\"language-text\">console_mouse</code> option makes it\neasier to copy/paste output from the terminal.</p>\n<h3>Start reverse proxy on port 8989 that directs traffic to port 4001</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mitmproxy —-listen-port 8989 —-ssl-insecure\n-—set console_mouse=false \n-—mode reverse:http://localhost:4001</code></pre></div>\n<h3>Navigation</h3>\n<ul>\n<li><code class=\"language-text\">j</code>/<code class=\"language-text\">k</code>: down/up</li>\n<li><code class=\"language-text\">enter</code>: select request</li>\n<li><code class=\"language-text\">q</code>: back/quit</li>\n<li><code class=\"language-text\">z</code>: clear requests</li>\n</ul>","id":"2dc02a05-3a0c-5cb7-9088-5f7dd6eaf0bb","frontmatter":{"title":"mitmproxy cheat sheet","date":"July 20, 2019","tags":["mitmproxy","proxy","cli","charlesproxy"]},"fields":{"slug":"/mitm-proxy-cheat-sheet/"}}},{"node":{"excerpt":"Postman has been my goto tool for API testing for the past year or so. When\nI hit a wall with using it I turn to All Things Postman. \nBut I realized most of what I end up looking for is the basic…","html":"<p><a href=\"https://www.getpostman.com/\">Postman</a> has been my goto tool for API testing for the past year or so. When\nI hit a wall with using it I turn to <a href=\"https://github.com/DannyDainton/All-Things-Postman\">All Things Postman</a>.\nBut I realized most of what I end up looking for is the basic stuff that covers 90 percent of my\ndaily use in one place.</p>\n<h3>Environment Variables</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pm.environment.set(&#39;someVariable&#39;, someValue)\npm.environment.get(&#39;someVariable&#39;)\npm.environment.unset(&#39;someVariable&#39;)</code></pre></div>\n<h3>Lodash</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//select random item from an array\n_.sample([a, b, c])\n\n//random number within a range\n_.random(1, 10)\n\n//repeat a command\n_.times(5, () =&gt; {\n    //do stuff\n})</code></pre></div>\n<h3>Moment</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var now = moment()\nvar tomorrow = moment().add(1, &#39;day&#39;)</code></pre></div>\n<h3>Tests</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pm.test(&#39;example test&#39;, () =&gt; {\n    pm.expect(pm.response.code).to.eql(200)\n    pm.expect(pm.response.status).to.eql(&#39;OK&#39;)\n\n    var response = pm.resonse.json()\n\n    if response.length === null throw new ERROR(    )\n\n    //verify response value\n    pm.expect(response.name).to.eql(&#39;Marc&#39;)\n    \n    //verify a date is a valid date\n    pm.expect(moment(response.date).isValid()).to.be.true\n\n    //verify result matches a regex\n    pm.expect(response.name).to.match(/[A-Z}{1}[a-z]{3}/)\n\n    //verify type of object\n    pm.expect(response.name).to.be.a(&#39;string&#39;)\n\n    //verify a header value\n    pm.expect(postman.getResponseHeader(&#39;some-header&#39;))\n        .to.eql(&#39;some-value&#39;)\n})</code></pre></div>\n<h3>Scripts</h3>\n<p>Send a post request</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pm.sendRequest({\n    url: &#39;http://testurl&#39;,\n    method: &#39;POST,\n    header: {\n        &#39;Content-Type&#39;: &#39;application/json&#39;\n    }\n    body: {\n        mode: &#39;raw&#39;,\n        raw: JSON.stringify(someJSON)\n    }, (err, res) =&gt;{\n        console.log((err ? err : res.json());\n    }\n});</code></pre></div>\n<p>Set next request (Note that this uses <code class=\"language-text\">postman</code> object and\nnot <code class=\"language-text\">pm</code> obect)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">postman.setNextRequest(&#39;name of request&#39;)</code></pre></div>\n<h3>Newman</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//run a collection\nnewman run my_collection.postman_collection.json\n\n//run with environment file\nnewman run my_collection.postman_collection.json \n-e my_environment.postman_environment.json\n\n//run with data file\nnewman run my_collection.postman_collection.jsonn -d data.json\n\n//disable SSL validations (useful if running through a proxy)\nnewman run my_collection.postman_collection.json --insecure</code></pre></div>","id":"5e81b094-bc66-5a76-9603-0a4c26fba8d6","frontmatter":{"title":"Postman cheat sheet","date":"June 12, 2019","tags":["postman","newman","lodash","moment"]},"fields":{"slug":"/postman-cheat-sheet/"}}},{"node":{"excerpt":"I've been using ngrok for a while and have become a big fan of it. But one of the clients I work\nwith is a large company with a large IT department and I assume a large committee that sits around\na…","html":"<p>I've been using <a href=\"/ngrok/\">ngrok</a> for a while and have become a big fan of it. But one of the clients I work\nwith is a large company with a large IT department and I assume a large committee that sits around\na large table discussing what apps they should block and dreaming up new firewall rules.</p>\n<p>So ngrok doesn't always work where I need it to. So I've had to rely on a few alternates, namely <a href=\"http://serveo.net/\">serveo</a>\nand <a href=\"https://github.com/localtunnel/localtunnel\">localtunnel</a>.</p>\n<h3>localtunnel</h3>\n<p><code class=\"language-text\">npm install -g localtunnel</code></p>\n<p><code class=\"language-text\">lt --port 3000</code></p>\n<h3>serveo</h3>\n<p><code class=\"language-text\">ssh -o ServerAliveInterval=60 -R 80:localhost:3000 serveo.net</code></p>\n<h3>TL;DR</h3>\n<ul>\n<li>localtunnel will work in a pinch, but I noticed some slowness when using it</li>\n<li>serveo doesn't require any installation and tries to re-use the same URL when it reconnects</li>\n</ul>\n<h3>Update</h3>\n<p><a href=\"http://localhost.run/\">localhost.run</a> is also an option.</p>\n<p><code class=\"language-text\">ssh -R 80:localhost:8080 ssh.localhost.run</code></p>","id":"aa020d08-37a0-561a-85be-794f474f898f","frontmatter":{"title":"More tunnels","date":"March 01, 2019","tags":["serveo","localtunnel","ngrok","network"]},"fields":{"slug":"/more-tunnels/"}}},{"node":{"excerpt":"I haven't had to do much mobile app testing recently, but last week I got dragged back in\nto it for an afternoon. I was very quickly reminded how much I hate testing mobile apps.The task I needed to…","html":"<p>I haven't had to do much mobile app testing recently, but last week I got dragged back in\nto it for an afternoon. I was very quickly reminded how much I hate testing mobile apps.</p>\n<p>The task I needed to accomplish was fairly straightforward: log in with a dozen or so\ntest accounts and verify that the accounts had been created correctly. This was going\nto be a one off activity so trying to automate it would have little ROI.</p>\n<p>But just having to type a dozen usernames and passwords on a phone keyboard is enough\nto try my patience, so I fall back to using <a href=\"https://developer.android.com/studio/command-line/adb\">Android Debug Bridge</a>.</p>\n<p>The problem is that I don't use adb often enough to remember how to use it. So I decided\nto write a simplified wrapper for it to make it simple to use the small subset of commands\nthat I actually need, specifically sending text and taking screenshots.</p>\n<p>If situations change and I get sucked back in to the mobile testing world, I may spend\nsome more time making this more usefull.</p>\n<h3>TL;DR</h3>\n<ul>\n<li><code class=\"language-text\">git clone git@github.com:marcallenbetts/android-test-util.git</code></li>\n<li><code class=\"language-text\">npm install</code></li>\n<li><code class=\"language-text\">node atu.js</code></li>\n<li><code class=\"language-text\">help</code></li>\n</ul>","id":"84118bbc-b211-55a5-8f26-adc513eb5b70","frontmatter":{"title":"Android test utils","date":"February 10, 2019","tags":["android","cli","mobile"]},"fields":{"slug":"/android-test-utils/"}}},{"node":{"excerpt":"Anybody who has worked with me for more than five minutes know that I have two \nbasic categories of test tools that I gravitate toward: proxies and command line\ntools.Proxies are great because they…","html":"<p>Anybody who has worked with me for more than five minutes know that I have two\nbasic categories of test tools that I gravitate toward: proxies and command line\ntools.</p>\n<p>Proxies are great because they give you valuable insight in to the network requests\nyour application is making that aren't usually visible from within the app. Command line\ntools are great for lots of reasons, mainly because junior developers and less tech savvy\npeople on the team will think you are some sort of super hacker wizard if they walk by and see\nyou frantically typing in a terminal window.</p>\n<p>But it's not alwasy obvious how to get your terminal to send network traffic to a proxy.</p>\n<p>These days I use <a href=\"https://www.getpostman.com/\">Postman</a> as my API test tool of choice. It's\na solid tool for testing and includes a commmand line runner (Newman). When using the GUI,\nit's really easy to see the requests and responses. When running Newman from the command line, not\nso much.</p>\n<p>So how do you configure CLIs to use a local proxy? Turns out you just need to set the <code class=\"language-text\">http_proxy</code>\nenvironment variable. And when you're done you can <code class=\"language-text\">unset</code> it. (Examples below use the default port for <a href=\"https://www.charlesproxy.com/\">Charles Proxy</a>).</p>\n<h3>TL;DR</h3>\n<ul>\n<li><code class=\"language-text\">export http_proxy=http://localhost:8888</code></li>\n<li><code class=\"language-text\">export https_proxy=http://localhost:8888</code></li>\n<li><code class=\"language-text\">unset http_proxy</code></li>\n<li><code class=\"language-text\">unset https_proxy</code></li>\n</ul>","id":"aeabd451-94eb-5b53-aa64-1efcb78efb6a","frontmatter":{"title":"Proxy command line processes","date":"January 20, 2019","tags":["proxy","charlesproxy","postman","newman","cli"]},"fields":{"slug":"/proxy-command-line-processes/"}}},{"node":{"excerpt":"I wasted a lot of time back in the day writing my API test frameworks. I learned\na lot from doing it, so I suppose it wasn't a total waste. The main thing I learned\nwas not to roll by own API…","html":"<p>I wasted a lot of time back in the day writing my API test frameworks. I learned\na lot from doing it, so I suppose it wasn't a total waste. The main thing I learned\nwas not to roll by own API frameworks.</p>\n<p>These days I'm using <a href=\"https://www.getpostman.com/\">Postman</a>. Its strength and weakness\nis that it does exactly one thing: sends API requests and tests the results. There is a\nJavaScript sandbox available, but the Postman team seems to have been very deliberate\nabout limiting the inclusion of extraneous JS libraries. So my natural instinct to want\nmy tests to upload test files, check database records, monitor log files, etc., is shut\ndown.</p>\n<p>But recently I cam across a scenario where I needed to verify an API response that required\nchecking a value that is intentionally not exposed to the user. For example, if a user is\nblacklisted you want to make sure that they are not allowed access to the system but you\ndon't necessarily want the user to know why they are blacklisted.</p>\n<p>So I set out to create the simplest API I could to check this so that my Postman scripts can\ncall the API to check the user status.  The database we're using is MongoDB, so I'm using\nMongoose. I've been using Express for some other projects I have in flight, so I decided to use\nit here as well.</p>\n<p>The whole thing is one file that clocks in at 24 lines of code. Let's take a look.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require (&#39;dotenv&#39;).config()</code></pre></div>\n<p><code class=\"language-text\">dotenv</code> allows the script to pull info out of a <code class=\"language-text\">.env</code> file\nso that environment configuration is stored separately from\nthe script.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var express = require(&#39;express&#39;)\nvar app = express()\nvar port = process.env.PORT || 4001</code></pre></div>\n<p>This is the configuration for the web server. The port number\nis pulled from the <code class=\"language-text\">.env</code> file. If it doesn't exist there,\nit will default to use port 4001.</p>\n<p>As an aside, I'm never sure how developers determine what\ndefault port to use for their projects. Using 80 or 8080 seems\npresumption to assume those are not already in use. I chose\n4001 because there is a <a href=\"https://en.wikipedia.org/wiki/Rickenbacker_4001\">Rickenbacker 4001</a> sitting\non the stand next to the desk in my home office.</p>\n<figure style=\"width: 300px\" class=\"align-center\">\n\t<img src=\"/assets/images/rickenbacker.jpg\">\n\t<figcaption>Author with Rickenbacker 4001 back when he still had hair.</figcaption>\n</figure>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var mongoose = require(&#39;mongoose&#39;)\nmongoose.connect(process.env.MONGO_CONNECTION_STRING,\n    { useNewUrlParser: true, useFindAndModify: false,\n    &#39;useCreateIndex&#39;: true })</code></pre></div>\n<p>MONGO<em>CONNECTION</em>STRING is how we tell mongoose to\nconnect to a specific MongoDB instance. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Schema = mongoose.Schema\n\nvar blacklisted = new Schema({\n    _id: mongoose.Types.ObjectId,\n    blacklisted: Object,\n})\n\nvar BlacklistedModel = mongoose.model(&#39;user&#39;, blacklistedSchema)</code></pre></div>\n<p>The mongoose schema defines the rules of what\ndata can be stored in the database. In a non-trivial\napp, schemas can be complicated beasts. My initial\nthought was to grab a copy of the actual schema our\napplication was using, but realized I would be going down the path of creating a bigger API than the one I was testing. So I chose to restrict the schema to\nthe <code class=\"language-text\">_id</code> of the user and their <code class=\"language-text\">blacklisted</code> status.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get(&#39;/user/:id&#39;, async (req, res) =&gt; {\n    var user = await BlacklistedModel.findOne(\n      {&#39;_id&#39;: mongoose.Types.ObjectId(req.params.id)}, \n      {&#39;_internal&#39;: 1})\n      .exec()\n    res.send(user)\n})</code></pre></div>\n<p>This is the piece that does the heavy lifting for our API. The route\nis define as <code class=\"language-text\">/user/:id</code>. When a request comes to that, mongoose will query the <code class=\"language-text\">user</code> collection with the id specified as <code class=\"language-text\">:id</code> and will return the response to the user.</p>\n<p>Request:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://localhost:4000/user/somemongodbuserid</code></pre></div>\n<p>Response:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n\t&quot;_id&quot;: &quot;somemongodbuserid&quot;,\n\t&quot;blacklisted&quot;: {\n\t\t&quot;reason&quot;: &quot;illegal activity&quot;,\n\t\t&quot;date&quot;: &quot;2019-01-03&quot;\n\t}\n}</code></pre></div>\n<p>With this I can now add requests to my Postman scripts\nto check user data that is not available our application's API.</p>\n<p>After using this for a short time, I made a couple of changes:</p>\n<ul>\n<li>Change the model and express route to a variable so that I could query any collection in the database</li>\n<li>Added a separate route to except query parameters so I could look up users by fields other than <code class=\"language-text\">_id</code></li>\n</ul>\n<h3>TL;DR</h3>\n<ul>\n<li><code class=\"language-text\">git clone git@github.com:marcallenbetts/simple-mongo-api.git</code></li>\n<li><code class=\"language-text\">npm install</code></li>\n<li><code class=\"language-text\">npm start</code></li>\n</ul>","id":"562b39e1-f422-5f2e-9e2e-7c1dbc915af4","frontmatter":{"title":"Creating an API to test an API","date":"January 05, 2019","tags":["postman","express","apitesting","mongoose","mongodb"]},"fields":{"slug":"/creating-an-api-to-test-an-api/"}}},{"node":{"excerpt":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris sapien nisi, consequat nec dolor ut, lobortis vestibulum nunc. Nulla facilisi. Suspendisse leo urna, pulvinar ut pretium sit amet…","html":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris sapien nisi, consequat nec dolor ut, lobortis vestibulum nunc. Nulla facilisi. Suspendisse leo urna, pulvinar ut pretium sit amet, consequat eget sapien. Nam ultricies in nulla finibus feugiat. Maecenas lacinia, lorem quis egestas convallis, tortor nunc consectetur est, vel finibus odio dui et nunc. Proin quis ante ut felis lacinia dignissim quis ac risus. Vestibulum a maximus est. Pellentesque malesuada eros ac diam aliquam, non pulvinar magna sodales. Fusce hendrerit malesuada quam, ut accumsan massa efficitur et. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Nullam vitae ornare sem, eget volutpat mauris. Praesent aliquet condimentum dui non bibendum. Nam dapibus rutrum mi sit amet luctus. Proin id vehicula risus. Nullam dictum, elit sit amet molestie eleifend, felis dolor scelerisque risus, sed dictum odio dolor id justo. Integer consectetur dui non tortor scelerisque, non vulputate sem laoreet:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const express = require(&#39;express&#39;)\nconst app = express()\nconst bodyParser = require(&#39;body-parser&#39;)\n\nconst cors = require(&#39;cors&#39;)\n\nconst mongoose = require(&#39;mongoose&#39;)\nmongoose.connect(process.env.DB_URI || &#39;mongodb://localhost/dbname&#39; )\n\napp.use(cors())\n\napp.use(bodyParser.urlencoded({extended: false}))\napp.use(bodyParser.json())\n\n\napp.use(express.static(&#39;public&#39;))\napp.get(&#39;/&#39;, (req, res) =&gt; {\n  res.sendFile(__dirname + &#39;/views/index.html&#39;)\n});\n\n\n// Not found middleware\napp.use((req, res, next) =&gt; {\n  return next({status: 404, message: &#39;not found&#39;})\n})\n\n\nconst listener = app.listen(process.env.PORT || 3000, () =&gt; {\n  console.log(&#39;Your app is listening on port &#39; + listener.address().port)\n})</code></pre></div>\n<br>\n<p>Nunc blandit purus sit amet justo vehicula, at venenatis ante tempus. Integer sagittis ultrices lorem, ut faucibus erat molestie quis. Phasellus semper orci nisl, egestas maximus risus porta sit amet. Fusce vitae egestas sem. Nunc sagittis, erat sodales maximus tempus, magna diam iaculis ex, ut feugiat odio libero sit amet lectus. Suspendisse elit turpis, volutpat laoreet consequat ac, ultricies eu sem. Donec non orci in justo porta iaculis. Donec pulvinar nunc quis viverra volutpat. Quisque et orci non enim sodales eleifend. Etiam in enim id nulla posuere lacinia. Ut rutrum pharetra nisi quis feugiat. Cras arcu lectus, euismod a lacinia a, cursus vitae magna. Aenean ultricies, enim id pharetra ultricies, ligula lectus congue tellus, ac lobortis ex elit at nulla. Sed lobortis vitae tortor sed laoreet. Praesent porta bibendum ullamcorper:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Not found middleware\napp.use((req, res, next) =&gt; {\n  return next({status: 404, message: &#39;not found&#39;})\n})\n\napp.post(&#39;/api/users/new-user&#39;, (req, res) =&gt;{\n const firstName = req.body.first_name;\n const lastName  = req.body.last_name;\n res.json({first_name: firstName, last_name: lastName, &quot;status&quot;: &quot;registered&quot;});\n})</code></pre></div>\n<br>\n<p>Integer fermentum euismod risus, vitae fringilla erat condimentum at. Suspendisse luctus egestas dui, eu dictum sem tincidunt sed. Sed efficitur eget orci eu dictum. Etiam faucibus, enim nec tincidunt sollicitudin, diam neque ultricies magna, eget ultrices sem tortor non justo. Vestibulum viverra tincidunt elit sit amet gravida. Morbi sed tempus odio. Nunc efficitur ultricies elit et porta. Praesent finibus placerat felis, vitae efficitur ligula sagittis non. Nam fringilla malesuada ligula ullamcorper dignissim.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.use((req, res, next) =&gt; {\n  console.log(&#39;fire 1&#39;)\n  return next({status: 404, message: &#39;not found&#39;})\n});\n\napp.post(&#39;/api/users/new-user&#39;, (req, res) =&gt;{\n  console.log(&#39;fire 2&#39;)\n  const firstName = req.body.first_name;\n  const lastName  = req.body.last_name;\n  res.json({first_name: firstName, last_name: lastName, &quot;status&quot;: &quot;registered&quot;});\n});</code></pre></div>\n<br>\n<p>Morbi mauris lacus, vehicula eget ullamcorper et, fringilla at ipsum. Nam tempus felis ex, congue varius urna consectetur eget. Cras tempor condimentum accumsan. In hac habitasse platea dictumst. Nulla pharetra mauris enim, quis dictum ipsum dictum sed. Sed luctus eros volutpat, luctus augue et, tempus ante:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Your app is listening on port 3000\nfire 1\n[object Object]</code></pre></div>\n<br>\n<p>Sed imperdiet diam id luctus faucibus. Sed ullamcorper suscipit arcu, in dictum lectus ultricies et. Donec accumsan a ipsum sed aliquet. Nulla auctor justo eget tincidunt egestas. Cras blandit, ante vitae facilisis hendrerit, justo mauris fermentum diam, id congue diam velit eu ipsum. Nullam pulvinar auctor tincidunt. Maecenas felis velit, bibendum ac purus nec, cursus lacinia nulla. Sed posuere orci sapien, id accumsan eros feugiat vel. Aenean convallis lacinia orci. In metus elit, iaculis vitae nisi vel, iaculis vehicula mi.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// not-found middleware\napp.use((req, res, next) =&gt; {\n  console.log(&#39;fire 1&#39;)\n  return next({status: 404, message: &#39;not found&#39;})\n});\n\n// error-handler middleware\napp.use((err, req, res, next) =&gt; {\n  console.log(&#39;fire 2&#39;)\n  console.log(err);\n  let errCode, errMessage\n\n  if (err.errors) {\n    // mongoose validation error\n    errCode = 400 // bad request\n    const keys = Object.keys(err.errors)\n    // report the first validation error\n    errMessage = err.errors[keys[0]].message\n  } else {\n    // generic or custom error\n    errCode = err.status || 500\n    errMessage = err.message || &#39;Internal Server Error&#39;\n  }\n  res.status(errCode).type(&#39;txt&#39;)\n    .send(errMessage)\n});\n\napp.post(&#39;/api/users/new-user&#39;, (req, res) =&gt;{\n  console.log(&#39;fire 3&#39;)\n  const firstName = req.body.first_name;\n  const lastName  = req.body.last_name;\n  res.json({first_name: firstName, last_name: lastName, &quot;status&quot;: &quot;registered&quot;});\n});</code></pre></div>\n<br>\n<p>Nam elementum augue vel nulla consectetur elementum. Curabitur tincidunt hendrerit justo. Praesent nisl dui, mollis vitae quam eu, dignissim faucibus lorem:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Your app is listening on port 3000\nfire 1\nfire 2\n{ status: 404, message: &#39;not found&#39; }</code></pre></div>\n<br>\n<p>Sed vitae erat at sem suscipit laoreet nec vel diam. Donec at quam sapien. Nulla quis egestas metus, ut tempus elit. Vivamus placerat diam ac ultrices finibus. Aenean vitae molestie eros. Curabitur pulvinar ornare est volutpat consequat. Vivamus ullamcorper pharetra leo ac volutpat. Curabitur efficitur egestas posuere. Duis ut sagittis diam, sed sollicitudin lectus. Phasellus in lorem maximus, volutpat felis non, fringilla mi. Curabitur in fringilla sem, nec rhoncus elit. Aenean non ante dignissim elit suscipit hendrerit sit amet nec eros. Curabitur feugiat, metus non convallis scelerisque, nisl urna imperdiet velit, eget semper enim ante eget lorem.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.post(&#39;/api/users/new-user&#39;, (req, res) =&gt;{\n  console.log(&#39;fire 1&#39;)\n  const firstName = req.body.first_name;\n  const lastName  = req.body.last_name;\n  res.json({first_name: firstName, last_name: lastName, &quot;status&quot;: &quot;registered&quot;});\n});\n\n\n// Not found middleware\napp.use((req, res, next) =&gt; {\n  console.log(&#39;fire 2&#39;)\n  return next({status: 404, message: &#39;not found&#39;})\n});\n\n// Error Handling middleware\napp.use((err, req, res, next) =&gt; {\n  console.log(&#39;fire 3&#39;)\n  console.log(err);\n  let errCode, errMessage\n\n  if (err.errors) {\n    // mongoose validation error\n    errCode = 400 // bad request\n    const keys = Object.keys(err.errors)\n    // report the first validation error\n    errMessage = err.errors[keys[0]].message\n  } else {\n    // generic or custom error\n    errCode = err.status || 500\n    errMessage = err.message || &#39;Internal Server Error&#39;\n  }\n  res.status(errCode).type(&#39;txt&#39;)\n    .send(errMessage)\n})</code></pre></div>\n<br>\n<p>Nulla pharetra mauris enim, quis dictum ipsum dictum sed. Sed luctus eros volutpat, luctus augue et, tempus ante. Sed imperdiet diam id luctus faucibus. Sed ullamcorper suscipit arcu, in dictum lectus ultricies et. Donec accumsan a ipsum sed aliquet. Nulla auctor justo eget tincidunt egestas:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Your app is listening on port 3000\nfire 1</code></pre></div>\n<br>\n<p> Donec at quam sapien. Nulla quis egestas metus, ut tempus elit. Vivamus placerat diam ac ultrices finibus. Aenean vitae molestie eros. Curabitur pulvinar ornare est volutpat consequat. Vivamus ullamcorper pharetra leo ac volutpat. Curabitur efficitur egestas posuere.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{&quot;first_name&quot;:&quot;Walter&quot;,&quot;last_name&quot;:&quot;White&quot;,&quot;status&quot;:&quot;registered&quot;}</code></pre></div>\n<br>\n<p>consectetur elementum.</p>","id":"21cf01b4-e10b-5b0b-b40a-a385f69f9b2e","frontmatter":{"title":"Misplaced Middleware in Express","date":"December 29, 2018","tags":["nodejs","express"]},"fields":{"slug":"/misplaced-middleware-in-express/"}}},{"node":{"excerpt":"The first question I ask when trying to figure out how to test something is \"what are the moving parts?\" I'm\nalways trying to see what is changing the helps understand what the application is doing. I…","html":"<p>The first question I ask when trying to figure out how to test something is \"what are the moving parts?\" I'm\nalways trying to see what is changing the helps understand what the application is doing. I'm looking for\nthings like database records that are touched or log file output. And in a lot of applications, it's\nnetwork requests.</p>\n<p>For network requests, knowing how to use a proxy is an invaluable tool. My current proxy of choice is\n<a href=\"https://www.charlesproxy.com/\">Charles Proxy</a>, but will turn to <a href=\"https://mitmproxy.org/\">mitmproxy</a> in a pinch.</p>\n<p>One of the apps I'm currently testing includes <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\">preflight requests</a>\nfor all API requests. I was trying to use Charles to rewrite some of the requests for some of the tests, but\ncouldn't find any way within Charles to distinguish between OPTIONS requests and POST requests. This was causing\nthe OPTIONS requests to get rewritten in a way that the app didn't care for.</p>\n<p>The solution I came up with was to use (NGINX)[https://www.nginx.com/] as a proxy to filter the requests before\nthey get to Charles. This allows me to route the OPTIONS request directly to the server to deal with and the POST\nrequests are sent to the proxy where they can manipulated for testing.</p>\n<p>The nginx.conf for this setup looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">server {\n\tlisten 8085;\n\terror_page 405 =200 $uri;\n\tlocation / {\n\t\tif ($request_method = OPTIONS) {\n\t\t\tproxy_pass REMOTE_HOST;\n\t\t}\n\t\tif ($request_method != OPTIONS) {\n\t\t\tproxy_pass LOCAL_HOST:8084;\n\t\t}\n\t}\n}</code></pre></div>\n<p>This will run NGINX on port 8085 and redirect all non-OPTIONS requests to a proxy\nserver running on port 8084. The proxy server needs to be configured as a reverse\nproxy on port 8084.</p>\n<h3>TL;DR</h3>\n<ol>\n<li>Configure a reverse proxy to listen on port 8084</li>\n<li>Configure app to use proxy on port 8085</li>\n<li><code class=\"language-text\">git clone git@github.com:marcallenbetts/nginx-proxy-and-errors.git</code></li>\n<li><code class=\"language-text\">docker-compose up --build</code></li>\n</ol>","id":"b8577c83-e952-59d8-9801-9fd079209d82","frontmatter":{"title":"Using NGINX as a filtering proxy","date":"December 23, 2018","tags":["nginx","proxy","charlesproxy","mitmproxy","webserver"]},"fields":{"slug":"/nginx-proxy-filter/"}}},{"node":{"excerpt":"This one line is the sum total of my knowledge of Python. Unless you count \"Python? That's the one that's really picking about spacing, right?\"A few years back I worked on a system that did web…","html":"<p>This one line is the sum total of my knowledge of Python. Unless you count \"Python? That's the one that's really picking about spacing, right?\"</p>\n<p>A few years back I worked on a system that did web scraping for content. So when testing that we were gathering web pages correctly, it was useful to have a web server up and running. Being generally lazy, I opted for the path of least resistance: use web servers that other people maintained for me.</p>\n<p>So I had countless free hosting accounts with all the shadiest free hosting outfits a Google search would return. Most of which would disappear without a trace a few months later.</p>\n<p>Later, one of the devs introduced me to Python's SimpleHTTPServer. It's pretty much what the name implies. A simple http server that will serve up static content to GET requests. This is also my goto for quickly mocking or modding an API response for a web page or a mobile app.</p>\n<h3>TL;DR</h3>\n<p><code class=\"language-text\">python -mSimpleHTTPServer 8081</code></p>","id":"c3fe51b0-9653-541e-9ae9-53a142b0286d","frontmatter":{"title":"Python SimpleHTTPServer","date":"December 20, 2018","tags":["python","webserver"]},"fields":{"slug":"/python-simple-http-server/"}}},{"node":{"excerpt":"Another subject I know very little about is networking. I know my computer has to connect to wifi to access the internet. But if you held a gun to my head and asked me to explain how that works, this…","html":"<p>Another subject I know very little about is networking. I know my computer has to connect to wifi to access the internet. But if you held a gun to my head and asked me to explain <em>how</em> that works, this would be a very short post.</p>\n<p>I do know that when setting up tests, running services locally is usually the path of least resistance. If you're running tests from the same machine, there's generally no friction.</p>\n<p>But sometimes you need to share a locally running resource with a different machine that may or may not be on the same network. You can go down the rabbit hole of trying to deploy to a publicly available site, or go the easy route and set up a tunnel to your local machine.</p>\n<p>Enter <a href=\"https://ngrok.com/\">ngrok</a>. This is a service that allows you to open up a port on your local machine and make it publicly available.</p>\n<p>To install: <code class=\"language-text\">npm install -g ngrok</code></p>\n<p>You need to create a free account with ngrok, but they support both Github and Google auth so you can be up and running in just a few minutes. After logging in, running ngrok with a protocol and a port number will give you a publicly facing URL that is valid for 24 hours. (I'm pretty sure they have paid versions with more flexibility, but I haven't need that yet.)</p>\n<h3>TL;DR</h3>\n<p><code class=\"language-text\">ngrok http 8081</code></p>\n<p><code class=\"language-text\">ngrok help</code></p>","id":"74e2a949-81ea-5b9e-a13e-f749dec12ac4","frontmatter":{"title":"ngrok","date":"December 08, 2018","tags":["ngrok","network"]},"fields":{"slug":"/ngrok/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}