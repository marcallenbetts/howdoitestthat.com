{"componentChunkName":"component---src-templates-tag-js","path":"/tags/postman/","result":{"data":{"site":{"siteMetadata":{"title":"How Do I Test That?","author":"Marc Betts","labels":[{"tag":"web","tech":"Web","name":"FaChrome","size":20,"color":"white"},{"tag":"react","tech":"React","name":"DiReact","size":20,"color":"deepskyblue"},{"tag":"git","tech":"Git","name":"DiGitMerge","size":20,"color":"white"},{"tag":"javascript","tech":"JavaScript","name":"DiJsBadge","size":20,"color":"yellow"},{"tag":"css","tech":"CSS","name":"DiCss3Full","size":20,"color":"teal"},{"tag":"python","tech":"Python","name":"DiPython","size":20,"color":"deepskyblue"},{"tag":"nodejs","tech":"Node.js","name":"DiNodejsSmall","size":20,"color":"lightgreen"},{"tag":"ruby","tech":"Ruby","name":"DiRuby","size":20,"color":"crimson"},{"tag":"java","tech":"Java","name":"FaJava","size":20,"color":"wheat"},{"tag":"angular","tech":"Angular","name":"DiAngularSimple","size":20,"color":"red"},{"tag":"html","tech":"HTML","name":"FaHtml5","size":20,"color":"darkorange"},{"tag":"php","tech":"php","name":"DiPhp","size":20,"color":"violet"},{"tag":"mongodb","tech":"MongoDB","name":"DiMongodb","size":20,"color":"green"},{"tag":"mongoose","tech":"Mongoose","name":"DiMongodb","size":20,"color":"green"},{"tag":"vscode","tech":"VS Code","name":"DiVisualstudio","size":20,"color":"deepskyblue"},{"tag":"android","tech":"Android","name":"DiAndroid","size":20,"color":"green"},{"tag":"ios","tech":"iOS","name":"FaApple","size":20,"color":"white"},{"tag":"cli","tech":"cli","name":"DiTerminal","size":20,"color":"white"},{"tag":"curl","tech":"curl","name":"DiTerminal","size":20,"color":"white"},{"tag":"mobile","tech":"Mobile","name":"FaMobileAlt","size":20,"color":"white"},{"tag":"proxy","tech":"proxy","name":"FaServer","size":20,"color":"white"},{"tag":"charlesproxy","tech":"CharlesProxy","name":"FaTools","size":20,"color":"white"},{"tag":"mitmproxy","tech":"mitmproxy","name":"FaTools","size":20,"color":"white"},{"tag":"postman","tech":"Postman","name":"DiTerminal","size":20,"color":"white"},{"tag":"newman","tech":"Newman","name":"FaTools","size":20,"color":"white"},{"tag":"express","tech":"Express","name":"FaJsSquare","size":20,"color":"white"},{"tag":"webserver","tech":"webserver","name":"FaServer","size":20,"color":"white"},{"tag":"nginx","tech":"NGINX","name":"FaServer","size":20,"color":"white"},{"tag":"apitesting","tech":"APITesting","name":"FaServer","size":20,"color":"white"},{"tag":"serveo","tech":"Serveo","name":"FaTools","size":20,"color":"white"},{"tag":"ngrok","tech":"ngrok","name":"FaTools","size":20,"color":"white"},{"tag":"localtunnel","tech":"Localtunnel","name":"FaTools","size":20,"color":"white"},{"tag":"network","tech":"Network","name":"FaEthernet","size":20,"color":"white"},{"tag":"lodash","tech":"Lodash","name":"FaJsSquare","size":20,"color":"white"},{"tag":"moment","tech":"Moment","name":"FaJsSquare","size":20,"color":"white"}]}},"allMarkdownRemark":{"totalCount":5,"edges":[{"node":{"excerpt":"I use lodash as my goto JS utility library. One\nof the main reasons is that it's included with Postman and I'm too lazy to\nuse one tool in Postman and a different one elsewhere. What is not…","html":"<p>I use <a href=\"https://lodash.com/\">lodash</a> as my goto JS utility library. One\nof the main reasons is that it's included with Postman and I'm too lazy to\nuse one tool in <a href=\"https://www.postman.com/\">Postman</a> and a different one elsewhere.</p>\n<p>What is not immediatley apparent in Postman is that it actually includes\ntwo versions of lodash. The default is (currently) 3.10.1. If you want to use\na newer version (currently 4.17.15), you can by overriding the default.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(_.VERSION)\n// 3.10.1\n\n_ = require(&#39;lodash&#39;)\nconsole.log(_.VERSION)\n// 4.17.15</code></pre></div>","id":"f1e127a1-d43e-5ef5-91c9-15ccf17aa853","frontmatter":{"title":"Postman and lodash","date":"May, 2020","tags":["postman","lodash"]},"fields":{"slug":"/postman-lodash/"}}},{"node":{"excerpt":"I use Postman for a lot of my API testing, including generating test \ndata. For a long time I wished Postman would add faker to it's limited\nlist of included JS libraries. Then I realized it was…","html":"<p>I use Postman for a lot of my API testing, including generating test\ndata. For a long time I wished Postman would add faker to it's limited\nlist of included JS libraries. Then I realized it was already there, but\nthe documentation around it is just severely lacking.</p>\n<p>The Postman docs has a <a href=\"https://learning.postman.com/docs/postman/variables-and-environments/variables-list/\">variable list</a>,\nbut doesn't do a good job of explaining where they can be used. They work in the body\nor URL of a request, but not in a pre-request script or in a test.</p>\n<p>To work around that, do something like this in a test or pre-request script:</p>\n<p><code class=\"language-text\">pm.variables.replaceIn(&quot;{{$randomProductName}}&quot;)</code></p>","id":"63a4e282-6887-5e47-b611-dbc9f20be107","frontmatter":{"title":"Postman and faker","date":"March, 2020","tags":["postman","faker"]},"fields":{"slug":"/postman-faker/"}}},{"node":{"excerpt":"Postman has been my goto tool for API testing for the past year or so. When\nI hit a wall with using it I turn to All Things Postman.\nBut I realized most of what I end up looking for is the basic stuff…","html":"<p><a href=\"https://www.getpostman.com/\">Postman</a> has been my goto tool for API testing for the past year or so. When\nI hit a wall with using it I turn to <a href=\"https://github.com/DannyDainton/All-Things-Postman\">All Things Postman</a>.\nBut I realized most of what I end up looking for is the basic stuff that covers 90 percent of my\ndaily use in one place.</p>\n<h3>Environment Variables</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pm.environment.set(&#39;someVariable&#39;, someValue)\npm.environment.get(&#39;someVariable&#39;)\npm.environment.unset(&#39;someVariable&#39;)</code></pre></div>\n<h3>Lodash</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//select random item from an array\n_.sample([a, b, c])\n\n//random number within a range\n_.random(1, 10)\n\n//repeat a command\n_.times(5, () =&gt; {\n    //do stuff\n})</code></pre></div>\n<h3>Moment</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const now = moment()\nconst tomorrow = moment().add(1, &#39;day&#39;)</code></pre></div>\n<h3>JWT Token</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const jwt = jsonData.access_token.split(&#39;.&#39;)\nconsole.log(JSON.parse(atob(jwt[1])))</code></pre></div>\n<h3>Tests</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pm.test(&#39;example test&#39;, () =&gt; {\n    pm.expect(pm.response.code).to.eql(200)\n    pm.expect(pm.response.status).to.eql(&#39;OK&#39;)\n\n    const response = pm.resonse.json()\n\n    if response.length === null throw new ERROR(    )\n\n    //verify response value\n    pm.expect(response.name).to.eql(&#39;Marc&#39;)\n\n    //verify a date is a valid date\n    pm.expect(moment(response.date).isValid()).to.be.true\n\n    //verify result matches a regex\n    pm.expect(response.name).to.match(/[A-Z}{1}[a-z]{3}/)\n\n    //verify type of object\n    pm.expect(response.name).to.be.a(&#39;string&#39;)\n\n    //verify a header value\n    pm.expect(postman.getResponseHeader(&#39;some-header&#39;))\n        .to.eql(&#39;some-value&#39;)\n})</code></pre></div>\n<h3>Scripts</h3>\n<p>Send a post request</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pm.sendRequest(\n  {\n    url: &#39;http://testurl&#39;,\n    method: &#39;POST&#39;,\n    header: {\n      &#39;Content-Type&#39;: &#39;application/json&#39;\n    },\n    body: {\n      mode: &#39;raw&#39;,\n      raw: JSON.stringify(someJSON)\n    }\n  },\n  (err, res) =&gt; {\n    console.log(err ? err : res.json())\n  }\n)</code></pre></div>\n<p>Set next request (Note that this uses <code class=\"language-text\">postman</code> object and\nnot <code class=\"language-text\">pm</code> obect)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">postman.setNextRequest(&#39;name of request&#39;)</code></pre></div>\n<h3>Newman</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//run a collection\nnewman run my_collection.postman_collection.json\n\n//run with environment file\nnewman run my_collection.postman_collection.json\n-e my_environment.postman_environment.json\n\n//run with data file\nnewman run my_collection.postman_collection.jsonn -d data.json\n\n//disable SSL validations (useful if running through a proxy)\nnewman run my_collection.postman_collection.json --insecure</code></pre></div>","id":"4ac8deef-8269-56c2-90ac-d82e05c2a4c2","frontmatter":{"title":"Postman cheat sheet","date":"June, 2019","tags":["postman","newman","lodash","moment"]},"fields":{"slug":"/postman-cheat-sheet/"}}},{"node":{"excerpt":"Anybody who has worked with me for more than five minutes know that I have two \nbasic categories of test tools that I gravitate toward: proxies and command line\ntools. Proxies are great because they…","html":"<p>Anybody who has worked with me for more than five minutes know that I have two\nbasic categories of test tools that I gravitate toward: proxies and command line\ntools.</p>\n<p>Proxies are great because they give you valuable insight in to the network requests\nyour application is making that aren't usually visible from within the app. Command line\ntools are great for lots of reasons, mainly because junior developers and less tech savvy\npeople on the team will think you are some sort of super hacker wizard if they walk by and see\nyou frantically typing in a terminal window.</p>\n<p>But it's not alwasy obvious how to get your terminal to send network traffic to a proxy.</p>\n<p>These days I use <a href=\"https://www.getpostman.com/\">Postman</a> as my API test tool of choice. It's\na solid tool for testing and includes a commmand line runner (Newman). When using the GUI,\nit's really easy to see the requests and responses. When running Newman from the command line, not\nso much.</p>\n<p>So how do you configure CLIs to use a local proxy? Turns out you just need to set the <code class=\"language-text\">http_proxy</code>\nenvironment variable. And when you're done you can <code class=\"language-text\">unset</code> it. (Examples below use the default port for <a href=\"https://www.charlesproxy.com/\">Charles Proxy</a>).</p>\n<h3>TL;DR</h3>\n<ul>\n<li><code class=\"language-text\">export http_proxy=http://localhost:8888</code></li>\n<li><code class=\"language-text\">export https_proxy=http://localhost:8888</code></li>\n<li><code class=\"language-text\">unset http_proxy</code></li>\n<li><code class=\"language-text\">unset https_proxy</code></li>\n</ul>","id":"0a746cb0-582d-53ae-af9d-c03afa3a974f","frontmatter":{"title":"Proxy command line processes","date":"January, 2019","tags":["proxy","charlesproxy","postman","newman","cli"]},"fields":{"slug":"/proxy-command-line-processes/"}}},{"node":{"excerpt":"I wasted a lot of time back in the day writing my API test frameworks. I learned\na lot from doing it, so I suppose it wasn't a total waste. The main thing I learned\nwas not to roll by own API…","html":"<p>I wasted a lot of time back in the day writing my API test frameworks. I learned\na lot from doing it, so I suppose it wasn't a total waste. The main thing I learned\nwas not to roll by own API frameworks.</p>\n<p>These days I'm using <a href=\"https://www.getpostman.com/\">Postman</a>. Its strength and weakness\nis that it does exactly one thing: sends API requests and tests the results. There is a\nJavaScript sandbox available, but the Postman team seems to have been very deliberate\nabout limiting the inclusion of extraneous JS libraries. So my natural instinct to want\nmy tests to upload test files, check database records, monitor log files, etc., is shut\ndown.</p>\n<p>But recently I cam across a scenario where I needed to verify an API response that required\nchecking a value that is intentionally not exposed to the user. For example, if a user is\nblacklisted you want to make sure that they are not allowed access to the system but you\ndon't necessarily want the user to know why they are blacklisted.</p>\n<p>So I set out to create the simplest API I could to check this so that my Postman scripts can\ncall the API to check the user status.  The database we're using is MongoDB, so I'm using\nMongoose. I've been using Express for some other projects I have in flight, so I decided to use\nit here as well.</p>\n<p>The whole thing is one file that clocks in at 24 lines of code. Let's take a look.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require (&#39;dotenv&#39;).config()</code></pre></div>\n<p><code class=\"language-text\">dotenv</code> allows the script to pull info out of a <code class=\"language-text\">.env</code> file\nso that environment configuration is stored separately from\nthe script.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var express = require(&#39;express&#39;)\nvar app = express()\nvar port = process.env.PORT || 4001</code></pre></div>\n<p>This is the configuration for the web server. The port number\nis pulled from the <code class=\"language-text\">.env</code> file. If it doesn't exist there,\nit will default to use port 4001.</p>\n<p>As an aside, I'm never sure how developers determine what\ndefault port to use for their projects. Using 80 or 8080 seems\npresumption to assume those are not already in use. I chose\n4001 because there is a <a href=\"https://en.wikipedia.org/wiki/Rickenbacker_4001\">Rickenbacker 4001</a> sitting\non the stand next to the desk in my home office.</p>\n<figure style=\"width: 300px\" class=\"align-center\">\n\t<img src=\"/assets/images/rickenbacker.jpg\">\n\t<figcaption>Author with Rickenbacker 4001 back when he still had hair.</figcaption>\n</figure>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var mongoose = require(&#39;mongoose&#39;)\nmongoose.connect(process.env.MONGO_CONNECTION_STRING,\n    { useNewUrlParser: true, useFindAndModify: false,\n    &#39;useCreateIndex&#39;: true })</code></pre></div>\n<p>MONGO<em>CONNECTION</em>STRING is how we tell mongoose to\nconnect to a specific MongoDB instance. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Schema = mongoose.Schema\n\nvar blacklisted = new Schema({\n    _id: mongoose.Types.ObjectId,\n    blacklisted: Object,\n})\n\nvar BlacklistedModel = mongoose.model(&#39;user&#39;, blacklistedSchema)</code></pre></div>\n<p>The mongoose schema defines the rules of what\ndata can be stored in the database. In a non-trivial\napp, schemas can be complicated beasts. My initial\nthought was to grab a copy of the actual schema our\napplication was using, but realized I would be going down the path of creating a bigger API than the one I was testing. So I chose to restrict the schema to\nthe <code class=\"language-text\">_id</code> of the user and their <code class=\"language-text\">blacklisted</code> status.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get(&#39;/user/:id&#39;, async (req, res) =&gt; {\n    var user = await BlacklistedModel.findOne(\n      {&#39;_id&#39;: mongoose.Types.ObjectId(req.params.id)}, \n      {&#39;_internal&#39;: 1})\n      .exec()\n    res.send(user)\n})</code></pre></div>\n<p>This is the piece that does the heavy lifting for our API. The route\nis define as <code class=\"language-text\">/user/:id</code>. When a request comes to that, mongoose will query the <code class=\"language-text\">user</code> collection with the id specified as <code class=\"language-text\">:id</code> and will return the response to the user.</p>\n<p>Request:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://localhost:4000/user/somemongodbuserid</code></pre></div>\n<p>Response:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n\t&quot;_id&quot;: &quot;somemongodbuserid&quot;,\n\t&quot;blacklisted&quot;: {\n\t\t&quot;reason&quot;: &quot;illegal activity&quot;,\n\t\t&quot;date&quot;: &quot;2019-01-03&quot;\n\t}\n}</code></pre></div>\n<p>With this I can now add requests to my Postman scripts\nto check user data that is not available our application's API.</p>\n<p>After using this for a short time, I made a couple of changes:</p>\n<ul>\n<li>Change the model and express route to a variable so that I could query any collection in the database</li>\n<li>Added a separate route to except query parameters so I could look up users by fields other than <code class=\"language-text\">_id</code></li>\n</ul>\n<h3>TL;DR</h3>\n<ul>\n<li><code class=\"language-text\">git clone git@github.com:marcallenbetts/simple-mongo-api.git</code></li>\n<li><code class=\"language-text\">npm install</code></li>\n<li><code class=\"language-text\">npm start</code></li>\n</ul>","id":"1d8d0059-5d48-5184-8492-8bd4bd48cde8","frontmatter":{"title":"Creating an API to test an API","date":"January, 2019","tags":["postman","express","apitesting","mongoose","mongodb"]},"fields":{"slug":"/creating-an-api-to-test-an-api/"}}}]}},"pageContext":{"tag":"postman"}},"staticQueryHashes":["392256161","551055924","63159454"]}