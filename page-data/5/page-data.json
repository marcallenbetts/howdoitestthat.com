{"componentChunkName":"component---src-templates-post-list-js","path":"/5","result":{"data":{"site":{"siteMetadata":{"title":"How Do I Test That?","author":"Marc Betts","labels":[{"tag":"web","tech":"Web","name":"FaChrome","size":20,"color":"white"},{"tag":"react","tech":"React","name":"DiReact","size":20,"color":"deepskyblue"},{"tag":"git","tech":"Git","name":"DiGitMerge","size":20,"color":"white"},{"tag":"javascript","tech":"JavaScript","name":"DiJsBadge","size":20,"color":"yellow"},{"tag":"css","tech":"CSS","name":"DiCss3Full","size":20,"color":"teal"},{"tag":"python","tech":"Python","name":"DiPython","size":20,"color":"deepskyblue"},{"tag":"nodejs","tech":"Node.js","name":"DiNodejsSmall","size":20,"color":"lightgreen"},{"tag":"ruby","tech":"Ruby","name":"DiRuby","size":20,"color":"crimson"},{"tag":"java","tech":"Java","name":"FaJava","size":20,"color":"wheat"},{"tag":"angular","tech":"Angular","name":"DiAngularSimple","size":20,"color":"red"},{"tag":"html","tech":"HTML","name":"FaHtml5","size":20,"color":"darkorange"},{"tag":"php","tech":"php","name":"DiPhp","size":20,"color":"violet"},{"tag":"mongodb","tech":"MongoDB","name":"DiMongodb","size":20,"color":"green"},{"tag":"mongoose","tech":"Mongoose","name":"DiMongodb","size":20,"color":"green"},{"tag":"vscode","tech":"VS Code","name":"DiVisualstudio","size":20,"color":"deepskyblue"},{"tag":"android","tech":"Android","name":"DiAndroid","size":20,"color":"green"},{"tag":"ios","tech":"iOS","name":"FaApple","size":20,"color":"white"},{"tag":"cli","tech":"cli","name":"DiTerminal","size":20,"color":"white"},{"tag":"curl","tech":"curl","name":"DiTerminal","size":20,"color":"white"},{"tag":"mobile","tech":"Mobile","name":"FaMobileAlt","size":20,"color":"white"},{"tag":"proxy","tech":"proxy","name":"FaServer","size":20,"color":"white"},{"tag":"charlesproxy","tech":"CharlesProxy","name":"FaTools","size":20,"color":"white"},{"tag":"mitmproxy","tech":"mitmproxy","name":"FaTools","size":20,"color":"white"},{"tag":"postman","tech":"Postman","name":"DiTerminal","size":20,"color":"white"},{"tag":"newman","tech":"Newman","name":"FaTools","size":20,"color":"white"},{"tag":"express","tech":"Express","name":"FaJsSquare","size":20,"color":"white"},{"tag":"webserver","tech":"webserver","name":"FaServer","size":20,"color":"white"},{"tag":"nginx","tech":"NGINX","name":"FaServer","size":20,"color":"white"},{"tag":"apitesting","tech":"APITesting","name":"FaServer","size":20,"color":"white"},{"tag":"serveo","tech":"Serveo","name":"FaTools","size":20,"color":"white"},{"tag":"ngrok","tech":"ngrok","name":"FaTools","size":20,"color":"white"},{"tag":"localtunnel","tech":"Localtunnel","name":"FaTools","size":20,"color":"white"},{"tag":"network","tech":"Network","name":"FaEthernet","size":20,"color":"white"},{"tag":"lodash","tech":"Lodash","name":"FaJsSquare","size":20,"color":"white"},{"tag":"moment","tech":"Moment","name":"FaJsSquare","size":20,"color":"white"}]}},"allMarkdownRemark":{"totalCount":16,"edges":[{"node":{"excerpt":"I wasted a lot of time back in the day writing my API test frameworks. I learned\na lot from doing it, so I suppose it wasn't a total waste. The main thing I learned\nwas not to roll by own API…","html":"<p>I wasted a lot of time back in the day writing my API test frameworks. I learned\na lot from doing it, so I suppose it wasn't a total waste. The main thing I learned\nwas not to roll by own API frameworks.</p>\n<p>These days I'm using <a href=\"https://www.getpostman.com/\">Postman</a>. Its strength and weakness\nis that it does exactly one thing: sends API requests and tests the results. There is a\nJavaScript sandbox available, but the Postman team seems to have been very deliberate\nabout limiting the inclusion of extraneous JS libraries. So my natural instinct to want\nmy tests to upload test files, check database records, monitor log files, etc., is shut\ndown.</p>\n<p>But recently I cam across a scenario where I needed to verify an API response that required\nchecking a value that is intentionally not exposed to the user. For example, if a user is\nblacklisted you want to make sure that they are not allowed access to the system but you\ndon't necessarily want the user to know why they are blacklisted.</p>\n<p>So I set out to create the simplest API I could to check this so that my Postman scripts can\ncall the API to check the user status.  The database we're using is MongoDB, so I'm using\nMongoose. I've been using Express for some other projects I have in flight, so I decided to use\nit here as well.</p>\n<p>The whole thing is one file that clocks in at 24 lines of code. Let's take a look.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require (&#39;dotenv&#39;).config()</code></pre></div>\n<p><code class=\"language-text\">dotenv</code> allows the script to pull info out of a <code class=\"language-text\">.env</code> file\nso that environment configuration is stored separately from\nthe script.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var express = require(&#39;express&#39;)\nvar app = express()\nvar port = process.env.PORT || 4001</code></pre></div>\n<p>This is the configuration for the web server. The port number\nis pulled from the <code class=\"language-text\">.env</code> file. If it doesn't exist there,\nit will default to use port 4001.</p>\n<p>As an aside, I'm never sure how developers determine what\ndefault port to use for their projects. Using 80 or 8080 seems\npresumption to assume those are not already in use. I chose\n4001 because there is a <a href=\"https://en.wikipedia.org/wiki/Rickenbacker_4001\">Rickenbacker 4001</a> sitting\non the stand next to the desk in my home office.</p>\n<figure style=\"width: 300px\" class=\"align-center\">\n\t<img src=\"/assets/images/rickenbacker.jpg\">\n\t<figcaption>Author with Rickenbacker 4001 back when he still had hair.</figcaption>\n</figure>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var mongoose = require(&#39;mongoose&#39;)\nmongoose.connect(process.env.MONGO_CONNECTION_STRING,\n    { useNewUrlParser: true, useFindAndModify: false,\n    &#39;useCreateIndex&#39;: true })</code></pre></div>\n<p>MONGO<em>CONNECTION</em>STRING is how we tell mongoose to\nconnect to a specific MongoDB instance. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Schema = mongoose.Schema\n\nvar blacklisted = new Schema({\n    _id: mongoose.Types.ObjectId,\n    blacklisted: Object,\n})\n\nvar BlacklistedModel = mongoose.model(&#39;user&#39;, blacklistedSchema)</code></pre></div>\n<p>The mongoose schema defines the rules of what\ndata can be stored in the database. In a non-trivial\napp, schemas can be complicated beasts. My initial\nthought was to grab a copy of the actual schema our\napplication was using, but realized I would be going down the path of creating a bigger API than the one I was testing. So I chose to restrict the schema to\nthe <code class=\"language-text\">_id</code> of the user and their <code class=\"language-text\">blacklisted</code> status.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get(&#39;/user/:id&#39;, async (req, res) =&gt; {\n    var user = await BlacklistedModel.findOne(\n      {&#39;_id&#39;: mongoose.Types.ObjectId(req.params.id)}, \n      {&#39;_internal&#39;: 1})\n      .exec()\n    res.send(user)\n})</code></pre></div>\n<p>This is the piece that does the heavy lifting for our API. The route\nis define as <code class=\"language-text\">/user/:id</code>. When a request comes to that, mongoose will query the <code class=\"language-text\">user</code> collection with the id specified as <code class=\"language-text\">:id</code> and will return the response to the user.</p>\n<p>Request:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://localhost:4000/user/somemongodbuserid</code></pre></div>\n<p>Response:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n\t&quot;_id&quot;: &quot;somemongodbuserid&quot;,\n\t&quot;blacklisted&quot;: {\n\t\t&quot;reason&quot;: &quot;illegal activity&quot;,\n\t\t&quot;date&quot;: &quot;2019-01-03&quot;\n\t}\n}</code></pre></div>\n<p>With this I can now add requests to my Postman scripts\nto check user data that is not available our application's API.</p>\n<p>After using this for a short time, I made a couple of changes:</p>\n<ul>\n<li>Change the model and express route to a variable so that I could query any collection in the database</li>\n<li>Added a separate route to except query parameters so I could look up users by fields other than <code class=\"language-text\">_id</code></li>\n</ul>\n<h3>TL;DR</h3>\n<ul>\n<li><code class=\"language-text\">git clone git@github.com:marcallenbetts/simple-mongo-api.git</code></li>\n<li><code class=\"language-text\">npm install</code></li>\n<li><code class=\"language-text\">npm start</code></li>\n</ul>","id":"1d8d0059-5d48-5184-8492-8bd4bd48cde8","frontmatter":{"title":"Creating an API to test an API","date":"January 05, 2019","tags":["postman","express","apitesting","mongoose","mongodb"]},"fields":{"slug":"/creating-an-api-to-test-an-api/"}}},{"node":{"excerpt":"The first question I ask when trying to figure out how to test something is \"what are the moving parts?\" I'm\nalways trying to see what is changing the helps understand what the application is doing. I…","html":"<p>The first question I ask when trying to figure out how to test something is \"what are the moving parts?\" I'm\nalways trying to see what is changing the helps understand what the application is doing. I'm looking for\nthings like database records that are touched or log file output. And in a lot of applications, it's\nnetwork requests.</p>\n<p>For network requests, knowing how to use a proxy is an invaluable tool. My current proxy of choice is\n<a href=\"https://www.charlesproxy.com/\">Charles Proxy</a>, but will turn to <a href=\"https://mitmproxy.org/\">mitmproxy</a> in a pinch.</p>\n<p>One of the apps I'm currently testing includes <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\">preflight requests</a>\nfor all API requests. I was trying to use Charles to rewrite some of the requests for some of the tests, but\ncouldn't find any way within Charles to distinguish between OPTIONS requests and POST requests. This was causing\nthe OPTIONS requests to get rewritten in a way that the app didn't care for.</p>\n<p>The solution I came up with was to use (NGINX)[https://www.nginx.com/] as a proxy to filter the requests before\nthey get to Charles. This allows me to route the OPTIONS request directly to the server to deal with and the POST\nrequests are sent to the proxy where they can manipulated for testing.</p>\n<p>The nginx.conf for this setup looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">server {\n\tlisten 8085;\n\terror_page 405 =200 $uri;\n\tlocation / {\n\t\tif ($request_method = OPTIONS) {\n\t\t\tproxy_pass REMOTE_HOST;\n\t\t}\n\t\tif ($request_method != OPTIONS) {\n\t\t\tproxy_pass LOCAL_HOST:8084;\n\t\t}\n\t}\n}</code></pre></div>\n<p>This will run NGINX on port 8085 and redirect all non-OPTIONS requests to a proxy\nserver running on port 8084. The proxy server needs to be configured as a reverse\nproxy on port 8084.</p>\n<h3>TL;DR</h3>\n<ol>\n<li>Configure a reverse proxy to listen on port 8084</li>\n<li>Configure app to use proxy on port 8085</li>\n<li><code class=\"language-text\">git clone git@github.com:marcallenbetts/nginx-proxy-and-errors.git</code></li>\n<li><code class=\"language-text\">docker-compose up --build</code></li>\n</ol>","id":"032a6067-1191-578a-9e11-ff7f51691648","frontmatter":{"title":"Using NGINX as a filtering proxy","date":"December 23, 2018","tags":["nginx","proxy","charlesproxy","mitmproxy","webserver"]},"fields":{"slug":"/nginx-proxy-filter/"}}},{"node":{"excerpt":"This one line is the sum total of my knowledge of Python. Unless you count \"Python? That's the one that's really picking about spacing, right?\" A few years back I worked on a system that did web…","html":"<p>This one line is the sum total of my knowledge of Python. Unless you count \"Python? That's the one that's really picking about spacing, right?\"</p>\n<p>A few years back I worked on a system that did web scraping for content. So when testing that we were gathering web pages correctly, it was useful to have a web server up and running. Being generally lazy, I opted for the path of least resistance: use web servers that other people maintained for me.</p>\n<p>So I had countless free hosting accounts with all the shadiest free hosting outfits a Google search would return. Most of which would disappear without a trace a few months later.</p>\n<p>Later, one of the devs introduced me to Python's SimpleHTTPServer. It's pretty much what the name implies. A simple http server that will serve up static content to GET requests. This is also my goto for quickly mocking or modding an API response for a web page or a mobile app.</p>\n<h3>TL;DR</h3>\n<p><code class=\"language-text\">python -mSimpleHTTPServer 8081</code></p>","id":"8d7bc656-5acc-5442-8feb-71836bcc1be9","frontmatter":{"title":"Python SimpleHTTPServer","date":"December 20, 2018","tags":["python","webserver"]},"fields":{"slug":"/python-simple-http-server/"}}}]}},"pageContext":{"limit":3,"skip":12,"numPages":6,"currentPage":5}},"staticQueryHashes":["392256161","551055924","63159454"]}